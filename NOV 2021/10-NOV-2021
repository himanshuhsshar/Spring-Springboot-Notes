09-NOV-2021
----------------------------------------------------------------------------------------------------------------------------------------------

How do you fix the bug?
1. Verify the bug reported by the QA is a bug or not.
2. try to reproduce in the bug.
3. Root Cause Analysis(RCA) to identify the problem.
4. identify the fix.
5. modifying the code.
6. conduct through unit testing.
7. push the code into SCM repository.
8. update the bug status to fixed with resolution comments (bug reporting tools).

new users / first-time registered users can avail 50% discount on their orders upto 100/- rupees max.

500 = 100/-
discount

As per the requirement the customer who has registered newly and placed order should get 50% discount.
testing steps conducted
1. register the new user into the system.
2. created an order of 500/- rupees.
3. system has give 100/- flat discount.
expected is 250/- but only give 100/- rupees it is a bug.


Switching from HTMLMessageFormatterImpl to PDFMessageFormatterImpl is an easy job from an developers perspective as it just takes few minutes time to
modify the code. But the time required for testing, certifying the code changes and moving the application across to the production env is quite costly
and takes huge amount of time. It requires huge efforts in coordinating across the teams in delivering the application into production which increase
cost and delivery time in deploying the changes.


10-NOV-2021
----------------------------------------------------------------------------------------------------------------------------------------------

class MessageWriter {
  private IMessageFormatter messageFormatter;
  public void writeMessage(String message) {
    String cMessage = null;
    
    // messageFormatter = new HTMLMessageFormatterImpl();
    // messageFormatter = MessageFormatterFactory.createMessageFormatter("html");
    
    /**
      When we are not creating or not pull the object, we will not references of another class inside our class, which makes our class completely loosely-coupled
    */
    
    cMessage = messageFormatter.formatMessage(message);
    System.out.println(cMessage);
  }
  public void setMessageFormatter(IMessageFormatter messageFormatter) {
    this.messageFormatter = messageFormatter;
  }
}

interface IMessageFormatter {
  String formatMessage(String message);
}

class HTMLMessageFormatterImpl implements MessageFormatter {
  public String formatMessage(String message) {
    return "<html><body>"+message+"</body></html>"
  }
}

class PDFMessageFormatterImpl implements MessageFormatter {
  public String formatMessage(String message) {
    return "<pdf>"+message+"</pdf>";
  }
}

class MessageFormatterFactory {
  public static IMessageFormatter createMessageFormatter(String type) {
    IMessageFormatter messageFormatter = null;
    
    if(type.equals("html")) {
      messageFormatter = new HTMLMessageFormatterImpl();
    }else if(type.equals("pdf")) {
      messageFormatter = new PDFMessageFormatterImpl();
    }
    return messageFormatter;
  }
}

class Test {
  public static void main(String[] args) {
    MessageWriter messageWriter = new MessageWriter();
    
    IMessageFormatter messageFormatter = MessageFormatterFactory.createMessageFormatter("pdf");
    messageWriter.setMessageFormatter(messageFormatter);
    
    messageWriter.writeMessage("Welcome to SDP");    
  }
}

When we are writing the classname or logical classname of another class inside our java classes we will be tightly coupled with another class. so if we want to switch from one class to another class we need to modify the code inside our java classes which requires.
  1. modification of our source (java) code
  2. to reflect the changes we modified we need to recompile and redeploy the application
  3. as we modified code we need certification of the code through testing process
  4. we need to restart the server to deliver the latest code  
The above process requires huge amount of efforts in managing and rolling the changes of our code.  
  
How to solve the problem?
dont write the classname or logical classname of another class inside our java class.  
  

properties always stores the data interms of key/value pair, given the key we can access the value uniquely.
  
appclasses.properties
----------------------
messageWriter.class=com.sdp.beans.MessageWriter
iMessageFormatter.class=com.sdp.beans.HTMLMessageFormatterImpl



11-NOV-2021
----------------------------------------------------------------------------------------------------------------------------------------------
When we use the classname or logical classname of another class inside a java class we will always be tightly coupled. So inorder to switch between the 
classes we need to modify the source code of the java class, even though the change seems to be simple to reflect the changes we made
1. need to recompile the application
2. repackage and redeploy
3. restart the server
4. need to certify the changes by testing the application by QA.
5. should follow the complete stages of delivery to release application in production with the changes.
From the above looks like a simple change in java class seems to be very costly and time taking process.

Don't write the classname or logical classname of another java inside a java class, rather write it somewhere else, read the classname and instantiate the
object.

To help us in accessing the classnames easily let us write the classnames in properties file. Properties is a key/valve format file in which we can store 
key as identifier of the class and value as full qualified name of the class.


app-classes.properties
messageWriter.class=com.sdp.beans.MessageWriter
messageFormatter.class=com.sdp.beans.HTMLMessageFormatterImpl
















